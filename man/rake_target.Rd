% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampling_raking.R
\name{rake_target}
\alias{rake_target}
\title{Rake sample to match population (Population input is a data frame of aggregated targets).}
\usage{
rake_target(
  df.svy = NA,
  targets = NA,
  reg.exp.vars = NA,
  reg.exp.cruz = NA,
  reg.exp.id = NA
)
}
\arguments{
\item{df.svy}{The sample \emph{dataframe}, containing the variables to be used in the analysis (unique id,
targets and cross-variable).}

\item{targets}{The population targets \emph{dataframe}, This df should have the following variables:
var (variable names),categ (categories labels), pop (pop dplyr::count) and the optional 'cruz' which identifies
 the crossing variable. Also, if there total pop dplyr::counts are different for each variable, this wont be
 corrected. The df layout is as follows:
\itemize{
 \item \strong{var}: column with the names of the target variables.
 \item \strong{categ}: column with the labels of the categories.
 \item \strong{pop}: population dplyr::count for each combination.
 \item \strong{var_cruz[Optional]}: identifier of each category of the crossing variable. The name of the
 column should match the name of the cross variable in the survey dataframe.
}}

\item{reg.exp.vars}{A \emph{string} with the regular expression identifying the target variables (i.e., those
variables that the sample total should match the population total). These variables should exist in both the
sample and population dataframes.}

\item{reg.exp.cruz}{[Optional] A \emph{string} with the regular expression identifying the variable which the target
variables are crossed by (usually reagion). The target variables will match the population within each label of
the crossing variable. These variables should exist in both the sample and population dataframes.}

\item{reg.exp.id}{A \emph{string} with the regular expression identifying the unique id variable. This variable
needs to exist only in the sample dataframe.}
}
\value{
A list with three components:
\itemize{
 \item \strong{weights}\emph{(dataframe)}: the original sample dataframe with the weights.
 \item \strong{check.vars}\emph{(dataframe)}: comparison of all variables and labels used.
 \item \strong{check.wgts}\emph{(dataframe)}: comparison of all weights and population totals.
}
}
\description{
This function rakes the sample to match the population counts. Missing values are excluded from the
raking and get value 1 before normalization. This algorithm has 3 basic steps:
\itemize{
 \item \strong{Check variables}: checks that same variables with same labels are in both dataframes.
 \item \strong{Rake sample}: Uses a adjusted raking algorithm adapted from
 in \code{\link[survey]{rake}}.
 \item \strong{Check weights}: Compares the weights to the population targets to make sure the raking
 worked.
}
}
\examples{
##load data
# Survey data
data(svy)
# Population data
data(pop)

## Raking WITHOUT crossing variable:
targets <- pop \%>\% dplyr::filter(!is.na(classe_cota),!is.na(idade_cota))
targets <- targets \%>\% dplyr::select(pesoe,sexo_cota,idade_cota,classe_cota) \%>\% dplyr::rename(pop=pesoe)
targets <- targets \%>\% tidyr::gather(var,categ,-pop)
targets <- targets \%>\% dplyr::group_by(var,categ) \%>\% dplyr::summarise(pop=sum(pop))
targets <- targets \%>\% dplyr::filter(is.na(categ) == FALSE)
teste.targets <- rake_target(df.svy=svy,targets=targets,reg.exp.vars="_cota$",reg.exp.cruz=NA,reg.exp.id="^numericalId$")

## Raking WITH crossing variable:
targets <- pop \%>\% dplyr::filter(!is.na(classe_cota),!is.na(idade_cota))
targets <- targets \%>\% dplyr::select(pesoe,regiao,sexo_cota,idade_cota,classe_cota) \%>\% dplyr::rename(pop=pesoe)
targets <- targets \%>\% tidyr::gather(var,categ,-regiao,-pop)
targets <- targets \%>\% dplyr::group_by(regiao,var,categ) \%>\% dplyr::summarise(pop=sum(pop))
targets.cruz <- targets \%>\% dplyr::filter(is.na(categ) == FALSE) \%>\% ungroup()
teste.targets.cruz <- rake_target(df.svy=svy,targets=targets.cruz,reg.exp.vars="_cota$",reg.exp.cruz="^regiao$",reg.exp.id="^numericalId$")
}
